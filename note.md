## CP4 基本模块化设计

### 开闭原则

- 开放扩展，封闭修改。
- 设计模式（复用pattern）
- 模块复用和系统复用
- 业务逻辑层和数据存储层
- 抽象实际上是选择性地忽略一些细节

## CP5 

- 参数化上下文
- 生死相依原则(create delete同时出现)

### 接口分类

- 共享数据或变量名
- call-in functions
- callback functions
- 同步调用接口
- 异步调用接口
  - 信号量、消息队列等方式实现

![image-20200829183638187](https://cdn.jsdelivr.net/gh/xmmmmmovo/ResourcesBackup/blog/pics/20200829183645.png)

### 接口设计

不要太具体，也不要太一般(通用)

## CP6

对于程序员来讲多线程意味着什么？

- 多线程

函数的可重入性（reentrant）

线程安全

- 可重入的函数是线程安全的吗？

用互斥锁让linkedlist中所有函数可重入

- 互斥锁

如何使linkedlist线程安全呢？

- 读写锁

**什么是函数的可重入性？**

可重入（reentrant）函数可以由多于一个任务并发使用，而不必担心数据错误。相反，不可重入（non-reentrant）函数不能由超过一个任务所共享，除非能确保函数的互斥（或者使用信号量，或者在代码的关键部分禁用中断）。可重入函数可以在任意时刻被中断，稍后再继续运行，不会丢失数据。可重入函数要么使用本地变量，要么在使用全局变量时保护自己的数据。

**可重入函数：**

不为连续的调用持有静态数据。

不返回指向静态数据的指针；所有数据都由函数的调用者提供。

使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。

绝不调用任何不可重入函数。

**两个或多个线程同时进入一个函数执行**

**什么是线程安全？**

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 

线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行读写操作，一般都需要考虑线程同步，否则就可能影响线程安全。

**函数的可重入性与线程安全之间的关系**

- 可重入的函数不一定是线程安全的；
- 可重入的函数在多个线程中并发使用时是线程安全的，但不同的可重入函数（共享全局变量及静态变量）在多个线程中并发使用时会有线程安全问题（可能是线程安全的也可能不是线程安全的）；
- 不可重入的函数一定不是线程安全的；

### 线程

- 函数调用堆栈

- 全局变量是典型的线程之间共享的资源